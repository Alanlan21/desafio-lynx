# Plan: Sistema de Gestão de Pedidos Lynx

Este plano implementa uma API REST em ASP.NET Core com Dapper + SQLite para gerenciar produtos, pedidos e pagamentos, seguindo os princípios de código explicável e arquitetura clara definidos em AGENT_GUIDELINES.md.

**Decisões-chave tomadas:**
- **Dapper** como micro-ORM (SQL explícito, mais controle)
- **Snapshot de preços** (sempre captura preço atual do produto, ignora preço enviado)
- **Seeding via script SQL** separado (execução manual)
- **Validação de pagamento duplicado** (impede novo pagamento se pedido já está PAID)
- **Filtros completos** em produtos (categoria, ativo, nome - todos opcionais)
- **GET /orders resumido** inclui total calculado + nome do cliente

---

## Steps

### 1. Configuração de Banco de Dados e Infraestrutura

**1.1** Adicionar pacote Dapper ao DesafioLynx.Api.csproj:
- `dotnet add package Dapper`
- `dotnet add package Microsoft.Data.Sqlite`


**1.2** Criar script database-setup.sql na raiz do projeto com:
- DDL completo das 5 tabelas (customers, products, orders, order_items, payments) conforme REQUISITOS.md
- INSERT de dados iniciais (5-10 produtos em categorias variadas, 2-3 clientes, 1-2 pedidos de exemplo)

**1.3** Adicionar connection string no appsettings.json:
```json
"ConnectionStrings": {
  "DefaultConnection": "Data Source=lynx-pedidos.db"
}
```

**1.4** Criar classe `DatabaseConfig` em Data/DatabaseConfig.cs:
- Classe estática com método `InitializeDatabase(string connectionString)` 
- **Implementação explícita passo a passo**:
  1. Extrair caminho do arquivo .db da connection string (parsing manual da string "Data Source=...")
  2. Usar `File.Exists(dbPath)` para verificar se banco já existe
  3. Se não existir:
     - Criar `SqliteConnection` e abrir conexão
     - Ler arquivo `database-setup.sql` com `File.ReadAllText()`
     - Executar SQL usando `SqliteCommand` (comando direto, sem helpers)
     - Fechar conexão explicitamente
  4. Logar cada etapa (arquivo existe/criado, SQL executado, etc)
- **Sem abstrações**: Tudo SQL manual, abertura/fechamento de conexão explícito
- **Conceito**: Classe utilitária de inicialização - executa setup do banco de forma imperativa

**1.5** Registrar inicialização no Program.cs:
- Após `var app = builder.Build();`
- Obter connection string via `app.Configuration.GetConnectionString("DefaultConnection")`
- Verificar se ambiente é Development com `app.Environment.IsDevelopment()`
- Se true, chamar `DatabaseConfig.InitializeDatabase(connectionString)`
- **Sem DI aqui**: Método estático chamado diretamente, sem injeção de dependências

---

### 2. Camada de Modelos (Entities)

Criar classes de domínio em Models/ mapeando diretamente as tabelas do banco:

**2.1** Models/Customer.cs:
- Propriedades: `Id`, `Name`, `Email`, `CreatedAt`
- Usar tipos C# apropriados (int, string, DateTime)

**2.2** Models/Product.cs:
- Propriedades: `Id`, `Name`, `Category`, `PriceCents`, `Active`
- Usar tipos C# apropriados (int, string, int, bool)

**2.3** Models/Order.cs:
- Propriedades: `Id`, `CustomerId`, `Status`, `CreatedAt`
- `Status` como string (valores: "NEW", "PAID", "CANCELLED")
- **Alternativa**: criar enum `OrderStatus` para type-safety

**2.4** Models/OrderItem.cs:
- Propriedades: `Id`, `OrderId`, `ProductId`, `Quantity`, `UnitPriceCents`

**2.5** Models/Payment.cs:
- Propriedades: `Id`, `OrderId`, `Method`, `AmountCents`, `PaidAt`
- `Method` como string (valores: "PIX", "CARD", "BOLETO")
- **Alternativa**: criar enum `PaymentMethod`

**Nota**: Essas classes são **apenas estruturas de dados** (DTOs de persistência), sem lógica de negócio.

---

### 3. Camada de DTOs (Contratos da API)

Criar DTOs em DTOs/ separando responsabilidades de entrada/saída:

**3.1** DTOs de Request:
- CreateOrderRequest.cs: `CustomerId`, `Items[]` (ProductId, Quantity)
- CreatePaymentRequest.cs: `OrderId`, `Method`, `AmountCents`

**3.2** DTOs de Response:
- ProductResponse.cs: todos campos de `Product`
- OrderSummaryResponse.cs: `Id`, `CustomerId`, `CustomerName`, `Status`, `CreatedAt`, `TotalCents`
- OrderDetailResponse.cs: extende `OrderSummaryResponse` + `Items[]` (incluindo nome do produto)
- OrderCreatedResponse.cs: `OrderId`, `TotalCents`, `Status`

**3.3** DTOs de Filtro:
- ProductFilterRequest.cs: `Category?`, `Active?`, `Name?` (todos opcionais, binding via [FromQuery])

**Conceito**: DTOs garantem que a API não exponha diretamente entidades do banco, permitindo evoluir o modelo interno sem quebrar contratos.

---

### 4. Camada de Acesso a Dados (Data Layer)

Criar classes de acesso a dados em Data/ usando Dapper:

**4.1** Data/IDbConnectionFactory.cs:
- Interface com método `IDbConnection CreateConnection()`
- **Conceito**: Factory pattern para criar conexões SQLite sob demanda

**4.2** Data/SqliteConnectionFactory.cs:
- Implementa `IDbConnectionFactory`
- Recebe connection string via construtor
- Cria `SqliteConnection` nova a cada chamada
- **Conceito Dapper**: Diferente de EF Core (DbContext), Dapper usa conexões diretas sem tracking

**4.3** Data/ProductRepository.cs:
- `Task<IEnumerable<Product>> GetAllAsync(ProductFilterRequest filter)`
- Montar SQL dinâmico baseado em filtros não-nulos
- Usar Dapper `QueryAsync<Product>` com parâmetros
- **Conceito**: Repository pattern - abstrai SQL de quem consome

**4.4** Data/OrderRepository.cs:
- `Task<IEnumerable<OrderSummaryResponse>> GetAllSummariesAsync()`
- SQL com JOIN para buscar customer.name e SUM para total
- `Task<OrderDetailResponse?> GetByIdWithDetailsAsync(int id)`
- SQL com múltiplos JOINs (orders → customers, order_items → products)
- `Task<int> CreateAsync(Order order)` retorna ID gerado
- `Task CreateItemsAsync(int orderId, IEnumerable<OrderItem> items)` - insert em lote

**4.5** Data/PaymentRepository.cs:
- `Task<int> CreateAsync(Payment payment)`
- `Task<int> GetTotalPaidByOrderAsync(int orderId)` - soma de payments por pedido
- `Task UpdateOrderStatusAsync(int orderId, string status)` - atualiza tabela orders

**Conceito Dapper**: Todo SQL é escrito manualmente. Isso dá controle total mas exige atenção a SQL injection (sempre usar parâmetros, nunca concatenar strings).

**Registrar no Program.cs**:
- `builder.Services.AddSingleton<IDbConnectionFactory, SqliteConnectionFactory>()`
- `builder.Services.AddScoped<ProductRepository>()`
- `builder.Services.AddScoped<OrderRepository>()`
- `builder.Services.AddScoped<PaymentRepository>()`

**Conceito DI**: Singleton para factory (stateless), Scoped para repositories (uma instância por request HTTP).

---

### 5. Camada de Serviços (Business Logic)

Criar services em Services/ com toda lógica de negócio:

**5.1** Services/ProductService.cs:
- Injeta `ProductRepository`
- `Task<IEnumerable<ProductResponse>> GetProductsAsync(ProductFilterRequest filter)`
- Chama repository e mapeia para DTO de resposta
- `Task<Product?> GetActiveProductByIdAsync(int id)` - valida se produto está ativo
- **Regra de negócio**: filtra apenas produtos ativos quando necessário

**5.2** Services/OrderService.cs:
- Injeta `OrderRepository`, `ProductRepository`
- `Task<IEnumerable<OrderSummaryResponse>> GetAllOrdersAsync()`
- `Task<OrderDetailResponse?> GetOrderDetailAsync(int id)`
- `Task<OrderCreatedResponse> CreateOrderAsync(CreateOrderRequest request)`
  - **Validação 1**: verificar se todos produtos existem e estão ativos
  - **Validação 2**: buscar preços atuais dos produtos (snapshot)
  - Criar entidade `Order` com status "NEW"
  - Criar `OrderItem[]` com preços capturados
  - Calcular total
  - Retornar resposta com ID gerado e total
- **Conceito**: Esta é a camada mais importante - Controllers NÃO contêm lógica, apenas delegam para Services

**5.3** Services/PaymentService.cs:
- Injeta `PaymentRepository`, `OrderRepository`
- `Task RegisterPaymentAsync(CreatePaymentRequest request)`
  - **Validação 1**: verificar se pedido existe
  - **Validação 2**: verificar se pedido já não está PAID (impedir pagamento duplicado)
  - Criar entidade `Payment` com `PaidAt = DateTime.UtcNow`
  - Buscar total pago até agora (soma de payments)
  - Buscar total do pedido (soma de order_items)
  - **Regra de negócio**: Se `totalPago >= totalPedido`, atualizar status para "PAID"
- **Conceito**: Encapsula lógica complexa de mudança de estado

**Registrar no Program.cs**:
- `builder.Services.AddScoped<ProductService>()`
- `builder.Services.AddScoped<OrderService>()`
- `builder.Services.AddScoped<PaymentService>()`

---

### 6. Camada de Controllers (API Endpoints)

Criar controllers em Controllers/ - apenas adaptação HTTP:

**6.1** Controllers/ProductsController.cs:
- `[ApiController]`, `[Route("api/[controller]")]`
- Injeta `ProductService` via construtor
- `[HttpGet] GetProducts([FromQuery] ProductFilterRequest filter)`
- Retorna `Ok(await _productService.GetProductsAsync(filter))`
- **Conceito**: Controller em .NET Core ≈ Controller no NestJS - recebe request, delega para service, retorna response

**6.2** Controllers/OrdersController.cs:
- Injeta `OrderService`
- `[HttpGet] GetOrders()` → retorna lista resumida
- `[HttpGet("{id}")] GetOrderById(int id)` → retorna detalhe ou `NotFound()`
- `[HttpPost] CreateOrder([FromBody] CreateOrderRequest request)`
  - Try/catch para capturar exceções de validação do service
  - Retornar `BadRequest(error.Message)` em caso de validação falhar
  - Retornar `CreatedAtAction(nameof(GetOrderById), new { id }, response)` em caso de sucesso
- **Conceito**: Usar status HTTP apropriados (200, 201, 400, 404)

**6.3** Controllers/PaymentsController.cs:
- Injeta `PaymentService`
- `[HttpPost] RegisterPayment([FromBody] CreatePaymentRequest request)`
- Try/catch similar ao OrdersController
- Retornar `Ok()` ou `BadRequest()`

**Tratamento de Erros**:
- Services lançam exceções com mensagens claras (ex: `throw new InvalidOperationException("Produto X está inativo")`)
- Controllers capturam e transformam em respostas HTTP apropriadas
- **Alternativa avançada**: criar middleware global de exceções (não necessário para este projeto)

---

### 7. Testing e Validação Manual

**7.1** Executar aplicação:
- `dotnet run --project DesafioLynx.Api`
- Acessar Swagger UI em `http://localhost:5000/swagger`

**7.2** Testar endpoints na ordem:
1. `GET /api/products` - deve retornar produtos do seeding
2. `GET /api/products?category=Eletrônicos&active=true` - testar filtros
3. `POST /api/orders` com payload válido - verificar criação
4. `GET /api/orders` - verificar pedido listado
5. `GET /api/orders/{id}` - verificar detalhes com itens
6. `POST /api/payments` com valor parcial - verificar que status continua NEW
7. `POST /api/payments` com valor que complete o total - verificar mudança para PAID
8. `POST /api/payments` para pedido já PAID - verificar rejeição

**7.3** Validar regras de negócio:
- Tentar criar pedido com produto inativo → deve falhar com 400
- Verificar que preços salvos em order_items batem com produtos no momento da criação
- Verificar cálculo correto do total (soma de quantity * unit_price_cents)

---

### 8. Frontend React (Opcional - fora do escopo imediato)

**Nota**: O plano de backend está completo. O frontend React pode ser iniciado após validação completa da API. Estrutura sugerida:
- `create-react-app` ou `vite`
- Páginas: ProductList, Cart, OrderList, OrderDetail
- Componentes: ProductCard, ProductFilters, CartItem
- Services: api.js com fetch/axios para consumir endpoints

---

## Verification

1. **Compilação**: `dotnet build` sem erros
2. **Execução**: aplicação inicia e Swagger carrega
3. **Banco de dados**: arquivo `lynx-pedidos.db` criado com dados iniciais
4. **Endpoints**: todos 5 endpoints retornam respostas válidas no Swagger
5. **Regras de negócio**:
   - ✅ Produto inativo rejeitado em pedido
   - ✅ Preços capturados no momento da compra (snapshot)
   - ✅ Status muda para PAID quando pagamento completo
   - ✅ Pagamento duplicado (em pedido PAID) é rejeitado
6. **Estrutura de código**:
   - ✅ Controllers sem lógica de negócio
   - ✅ Services com todas validações e regras
   - ✅ DTOs separados de Models
   - ✅ SQL explícito nos repositories (Dapper)

---

## Decisions

- **Dapper sobre EF Core**: Controle total sobre SQL, performance otimizada, sem abstrações "mágicas" - facilita entendimento do que acontece no banco
- **Snapshot de preços**: Ignorar preço enviado no request, sempre capturar do produto - garante integridade e simplicidade (cliente não pode manipular preços)
- **Script SQL manual**: Setup explícito do banco, mais controle sobre dados iniciais, sem complexidade de migrations
- **Repository pattern com Dapper**: Abstrair SQL dos services mantendo queries explícitas
- **Services com regras de negócio**: Separação clara de responsabilidades - Controllers apenas HTTP, Services apenas lógica
- **Status CANCELLED preparado**: Incluir no banco/enum mas não implementar endpoint - facilita evolução futura
- **Validação de pagamento duplicado**: Impedir novo pagamento se pedido já PAID - evita inconsistências
